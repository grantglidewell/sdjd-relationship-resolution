import { Head, Image, Appear, Notes } from "mdx-deck";

export theme from "./theme";

<Head>
  <title>Relationships are hard</title>
</Head>

## Relationships are hard

### in React/Redux

###### .

#### Grant Glidewell

#### Front End Engineer with Zesty.io

---

<Image src="mgrapp.png" size="fill" />

```notes
  We recently released our new content management ui. This was a huge undertaking, were re-building our core product. Previously the app was a PHP monolith, our new release is built in React/Redux and relies heavily on a new golang rest api. This means we are now relying on calls to an api rather than directly manipulating a database. There are clear advantages with this approach, one being the code can be much cleaner as it’s purpose becomes more singular. It did, however, make some actions more difficult. One of those issues came in the form of relationships. But before we get into the problem, what do users expect from our manager application?

```

---

## Manager UI

<ul>
  <Appear>
    <li>See all the content associated with an instance</li>
    <li>Edit content, including metadata and various fields</li>
    <li>Publish content and iterate on versions</li>
    <li>Content's data structure is dictated by the user</li>
  </Appear>
</ul>

---

#### .

## The Problem

<Image src="listview.png" size="80%" />

```notes
In Zesty users can create content with completely custom data models. This means in many cases they want to create relationships between content. say pages that relate to one another in a specific way, an author that has written an article, or labeling certain content with tags. On the surface this seems simple enough.
```

---

#### .

## The Problem

<Image src="listview2.png" size="80%" />

```notes
In this case we are dealing with authors associated with the articles they have written
```

---

#### .

## The Problem

<Image src="relationship.png" size="60%" />

```notes
 We get an article for a user to edit, if the article has relationships we need to get the associated piece of data. However relationships usually point to a certain field on a piece of content, which requires you to lookup a field, requiring the content’s model, to reference a specific value. So now we’re dealing with a whole process to resolve the relationship.
```

---

## Solutions

### App Layers

<ul>
  <Appear>
    <li>Presentation Components</li>
    <li>Container Components</li>
    <li>Routing (HashRouter)</li>
    <li>Redux Store</li>
    <li>External Resources</li>
  </Appear>
</ul>

```notes
In trying to find a solution to this, we had to make some decisons on where the best place in our app would be to resolve these kinds of relationships.
```

---

## Solutions

### Component level resolution

<ul>
  <Appear>
    <li>Container components know what is and is not in the store</li>
    <li>They have the ability to dispatch actions</li>
    <li style={{ color: "orange" }}>HOWEVER...</li>
    <li style={{ color: "red" }}>
      They are UI, and should be decoupled from this kind of logic
    </li>
    <li style={{ color: "red" }}>This can lead to overly complex components</li>
  </Appear>
</ul>

```notes
Resolving relationships in a container component is possible as they have access to the store and can dispatch actions. But this is a really bad idea as our use of redux allows us to decouple them from these concerns. They should only concerned with what and how to render our views.
```

---

#### .

## Solutions

<Image src="listview3.png" size="80%" />

```notes
  Here we see that the relationship column in this list view has multiple relationships that resolve to the same value or piece of content. If we did resolve the relationships in react it would result in many redundant requests.
```

---

## Solutions

### Redux action/reducer

<ul>
  <Appear>
    <li>Direct store access</li>
    <li>Could be chained off of existing actions</li>
    <li style={{ color: "orange" }}>HOWEVER...</li>
    <li style={{ color: "red" }}>This reduces predictability of our actions</li>
    <li style={{ color: "red" }} />
    <li style={{ color: "red" }}>There is a place for this!</li>
  </Appear>
</ul>

```notes
Doing this in an action or reducer could make some sense as they are directly connected to the store and could be chained off of existing actions. This is however a slippery slope as these might lead to complicated actions that are less predictable.
```

---

## Solutions

### Middleware

<ul>
  <Appear>
    <li>Does not interfere with UI behavior</li>
    <li>Our actions are unaware</li>
    <li>We can track our requests</li>
    <li>We have direct store access</li>
  </Appear>
</ul>

---

## Middleware

```javascript
export const fetchResource = store => next => action => {
  if (action.type === "FETCH_RESOURCE") {
    if (`The request is not already in flight`) {
      inflight.push(action.uri);
      return request(action.uri);
    }
  }
};
```

```notes
essentially we check here if the request is in flight. if not we go ahead and send the request off. if it's in the array we call next() to continue the redux action on.
```

---

## Middleware

```javascript
export const resolveFieldOptions = store => next => action => {
  if (action.type === "FETCH_FIELDS_SUCCESS") {
    if (action.data) {
      if(field in data contains 'relationships'){
        parseRelationships().then(relatedItem => {
          dispatch({type: "FETCH_RESOURCE", uri: `uri.to.${relatedItem}`})
        })
      }
    }
  }
}
```

```notes
Now that we have resource requests de-duplicated, we have the chance to look at relationships at the first possible moment. Relationships are defined on the 'field', so if a field comes in that has a defined relationship, we can check the store for that data, and if it is not present, make a request for that resourse.
```

---

## Middleware

With this approach our other code is agnostic to relationship resolution.

Mental space is freed up to reason about other parts of the application.

---

## Middleware

Our redux store remains clean, components and actions are unaware that this is happening under the hood, and users dont have their browsers full of redundant requests.

---

## Relationship Resolution

### in React/Redux

###### .

#### Grant Glidewell

#### Front End Engineer with Zesty.io

###### grant@grantglidewell.com
