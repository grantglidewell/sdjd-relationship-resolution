import { Head, Image, Appear, Notes } from "mdx-deck";

export theme from "./theme";

<Head>
  <title>Relationships are hard</title>
</Head>

## Relationships are hard

### in React/Redux

###### .

#### Grant Glidewell

#### Front End Engineer with Zesty.io

---

## Manager UI

<ul>
  <Appear>
    <li>See all the content associated with an instance</li>
    <li>Edit content, including metadata and various fields</li>
    <li>Publish content and iterate on versions</li>
  </Appear>
</ul>

---

<Image src="mgrapp.png" size="cover" />
<Notes>
  We recently released our new content management ui. This was built in react and redux and relies heavily on a new golang rest api. This was a huge undertaking, as we were re-building our core product. Some issues we hit along the way were new problems, previously the app was a monolith, and now we were creating with an independent front and back end. This means we are now relying on calls to an api rather than directly hooking into a database. There are clear advantages with this approach, one being the code can be much cleaner as it’s purpose becomes more singular. I did, however, make some actions more difficult. One of those issues came in the form of relationships.

</Notes>

---

#### .

## The Problem

<Image src="listview.png" size="80%" />
<Notes>
In Zesty users can create content with completely custom data models. This means in many cases they want to create relationships between content. say pages that relate to one another in a specific way, an author that has written an article, or labeling certain content with tags. On the surface this seems simple enough.
</Notes>

---

#### .

## The Problem

<Image src="relationship.png" size="60%" />

<Notes>
 We get an article for a user to edit, if the article has relationships we fetch the associated piece of data. However relationships usually point to a certain field on a piece of content, which requires you to lookup a field, requiring the content’s model, to reference a specific value. So now we’re dealing with a whole process to resolve.
</Notes>
---

#### .

## The Problem

<Image src="listview2.png" size="80%" />

---

## Solutions

### App Layers

<ul>
  <Appear>
    <li>Presentation Components</li>
    <li>Container Components</li>
    <li>Routing (HashRouter)</li>
    <li>Redux Store</li>
    <li>External Resources</li>
  </Appear>
</ul>

---

## Solutions

### Component level resolution

<ul>
  <Appear>
    <li>Container components know what is and is not in the store</li>
    <li>The have the ability to dispatch actions</li>
    <li style={{color:'orange'}}>HOWEVER...</li>
    <li style={{color:'red'}}>They are UI, and should be decoupled from the store</li>
    <li style={{color:'red'}}>This can lead to overly complex components</li>
  </Appear>
</ul>
---

#### .

## Solutions

<Image src="listview3.png" size="80%" />

<Notes>
  Here we see that the relationship column in this list view has multiple
  relationships that resolve to the same content.
</Notes>

---

## Solutions

### Redux action/reducer

<ul>
  <Appear>
    <li>Direct store access</li>
    <li>Could be chained off of existing actions</li>
    <li style={{color:'orange'}}>HOWEVER...</li>
    <li style={{color:'red'}}>This reduces predictability of our actions</li>
    <li style={{color:'red'}}>Could lead to impure reducers</li>
  </Appear>
</ul>
---

## Solutions

### Middleware

---

## Middleware

```javascript
export const fetchResource = store => next => action => {
  if (action.type === "FETCH_RESOURCE") {
    if (`The request is not already in flight`) {
      inflight.push(action.uri);
      return request(action.uri);
    }
  }
};
```

```notes
Redux midleware requires some setup, but essentially we check here if the request is in flight. if not we go ahead and send the request off. if it's in the array we call next() to continue the redux action on.
```

---

## Middleware

```javascript
export const resolveFieldOptions = store => next => action => {
  if (action.type === "FETCH_FIELDS_SUCCESS") {
    if (action.data) {
      if(fields in data contains 'relationships'){
        parseRelationships().then(relatedItem => {
          dispatch({type: "FETCH_RESOURCE", uri: `uri.to.${relatedItem}`})
        })
      }
    }
  }
}
```

```notes
Now that we have requests de-duplicated, we have the chance to look at relationships at the first possible moment. Relationships are defined on the 'field', so if we look at what can be related, and fetch that data, we will have it when we need to render it.
```

---

## Relationship Resolution

### in React/Redux

###### .

#### Grant Glidewell

#### Front End Engineer with Zesty.io

###### grant@grantglidewell.com
